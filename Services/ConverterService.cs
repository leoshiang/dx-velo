using Microsoft.Extensions.Logging;

namespace Velo.Services;

/// <summary>
/// 轉換服務 - 靜態部落格生成的主要協調者
/// 負責統籌整個部落格轉換流程，從 Markdown 文章到完整的靜態網站
/// 此服務作為高層級的協調器，整合其他服務來完成完整的轉換作業
/// </summary>
/// <param name="blogService">部落格服務，負責文章資料的管理和載入</param>
/// <param name="markdownToHtmlService">Markdown 轉 HTML 服務，負責核心的轉換邏輯</param>
/// <param name="logger">日誌記錄器，用於記錄轉換過程中的重要資訊</param>
/// <remarks>
/// 設計模式說明：
/// - 採用 Facade Pattern（外觀模式），簡化複雜的轉換流程
/// - 使用依賴注入，確保各服務間的低耦合
/// - 實現責任分離原則，每個服務專注於特定功能
/// </remarks>
public class ConverterService(
    IBlogService blogService,
    IMarkdownToHtmlService markdownToHtmlService,
    ILogger<ConverterService> logger)
{
    #region 公開方法

    /// <summary>
    /// 轉換所有部落格文章
    /// 執行完整的靜態部落格生成流程，從掃描文章到產生最終的 HTML 檔案
    /// </summary>
    /// <returns>代表非同步操作的 Task</returns>
    /// <exception cref="Exception">當轉換過程中發生任何錯誤時拋出</exception>
    /// <remarks>
    /// 轉換流程概述：
    /// 1. 資料準備階段：重新掃描並載入所有 Markdown 文章
    /// 2. 轉換執行階段：將 Markdown 轉換為 HTML 並套用模板
    /// 3. 資源處理階段：複製圖片等靜態資源
    /// 4. 網站生成階段：產生首頁和完整的靜態網站結構
    /// 
    /// 效能考量：
    /// - 使用非同步處理，避免阻塞 UI 執行緒
    /// - 內部實現並行處理，提高轉換效率
    /// - 智能緩存機制，避免重複載入相同資源
    /// 
    /// 錯誤處理：
    /// - 採用 fail-fast 原則，遇到錯誤立即停止並報告
    /// - 詳細的錯誤日誌，便於問題診斷
    /// - 保持部分轉換結果，減少重新執行的成本
    /// </remarks>
    public async Task ConvertAllPostsAsync()
    {
        try
        {
            logger.LogInformation("開始轉換流程...");

            // ==========================================
            // 階段 1: 資料準備與文章掃描
            // ==========================================

            // <summary>
            // 強制重新掃描並載入所有文章
            // 
            // 為什麼需要強制重新載入：
            // 1. 檔案系統變更：確保捕捉到新增、修改或刪除的文章
            // 2. Front Matter 更新：重新解析文章的元資料（標題、分類、標籤等）
            // 3. 分類結構變更：重建分類樹狀結構
            // 4. 內容一致性：確保轉換基於最新的文章內容
            // 
            // 執行內容：
            // - 掃描 BlogContentPath 目錄下的所有 .md 檔案
            // - 解析每個檔案的 Front Matter 和內容
            // - 自動處理缺少 Front Matter 的檔案（如果設定啟用）
            // - 建立文章索引和分類對應關係
            // - 生成分類樹狀結構供導航使用
            // </summary>
            await blogService.ForceScanAndReloadPostsAsync();

            // ==========================================
            // 階段 2: 內容轉換與網站生成
            // ==========================================

            // <summary>
            // 執行完整的轉換和網站生成流程
            // 
            // 這個階段包含以下子流程：
            // 
            // 2.1 並行文章轉換：
            // - 將每篇 Markdown 文章轉換為 HTML
            // - 處理文章中的圖片路徑，轉換為網頁友善格式
            // - 套用文章模板，生成完整的文章頁面
            // - 提取並記錄文章中使用的圖片資源
            // 
            // 2.2 靜態資源處理：
            // - 複製文章中引用的圖片到輸出目錄
            // - 處理重複檔名，確保資源唯一性
            // - 清理無效的 file:// 協定路徑
            // - 最佳化圖片路徑結構
            // 
            // 2.3 網站結構生成：
            // - 生成網站首頁（index.html）
            // - 整合文章列表和分類導航
            // - 套用首頁模板和樣式
            // - 建立搜尋索引和互動功能
            // 
            // 2.4 輸出目錄管理：
            // - 根據設定決定是否清空輸出目錄
            // - 確保目錄結構正確建立
            // - 處理檔案權限和存取問題
            // </summary>
            await markdownToHtmlService.ConvertAndSaveAllPostsAsync();

            // ==========================================
            // 流程完成確認
            // ==========================================

            // <summary>
            // 記錄轉換完成的成功訊息
            // 
            // 此時整個靜態部落格已經生成完成，包含：
            // - 所有文章的 HTML 頁面
            // - 網站首頁和導航結構  
            // - 圖片等靜態資源
            // - 搜尋和互動功能
            // 
            // 使用者可以：
            // 1. 直接開啟 index.html 預覽網站
            // 2. 將整個輸出目錄上傳到網頁伺服器
            // 3. 使用本地伺服器進行測試
            // </summary>
            logger.LogInformation("轉換流程完成！");
        }
        catch (Exception ex)
        {
            // ==========================================
            // 錯誤處理與復原
            // ==========================================

            // <summary>
            // 全面的錯誤處理機制
            // 
            // 錯誤類型可能包括：
            // 1. 檔案系統錯誤：
            //    - 目錄不存在或無法存取
            //    - 檔案權限不足
            //    - 磁碟空間不足
            // 
            // 2. 內容處理錯誤：
            //    - Markdown 語法錯誤
            //    - Front Matter 格式不正確
            //    - 圖片檔案遺失或損壞
            // 
            // 3. 設定錯誤：
            //    - 路徑設定不正確
            //    - 模板檔案遺失
            //    - 編碼問題
            // 
            // 4. 系統資源錯誤：
            //    - 記憶體不足
            //    - 網路連線問題（如果有遠端資源）
            // 
            // 錯誤處理策略：
            // - 記錄詳細的錯誤資訊，包含堆疊追蹤
            // - 保留已完成的部分結果
            // - 提供有意義的錯誤訊息給使用者
            // - 重新拋出例外，讓上層處理使用者通知
            // </summary>
            logger.LogError(ex, "轉換流程發生錯誤");

            // <summary>
            // 重新拋出例外的原因：
            // 
            // 1. 責任分離：ConverterService 負責協調流程，不負責使用者介面
            // 2. 錯誤傳播：讓呼叫方（通常是 Program.cs）決定如何通知使用者
            // 3. 程式流程控制：讓上層決定是否要停止程式或進行其他處理
            // 4. 一致性：保持服務層的一致錯誤處理模式
            // </summary>
            throw;
        }
    }

    #endregion
}